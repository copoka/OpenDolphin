/*
 * OverlayImagePanel.java
 *
 * Created on 2001/09/02, 2:22
 */

package jp.ac.kumamoto_u.kuh.fc.jsato.swing_beans;

import java.awt.*;
import java.awt.image.*;
import javax.swing.*;
import java.awt.event.*;

/**
 *
 * @author  Junzo SATO
 * @copyright   Copyright (c) 2001, Junzo SATO. All rights reserved.
 */

public class OverlayImagePanelBean extends javax.swing.JPanel {
    /** Holds value of property overlay. */
    private Image overlay = null;
    
    /** Utility field used by bound properties. */
    private java.beans.PropertyChangeSupport propertyChangeSupport =  new java.beans.PropertyChangeSupport (this);
    
    /** Holds value of property image. */
    private Image srcImg = null;
    
    public int[] calcImageSize(Image img) {
        int[] size  = new int[2];
        size[0] = img.getWidth(this);
        size[1] = img.getHeight(this);
        return size;
    }
    
    private Graphics overlayG = null;
    
    public Graphics getOverlayG() {
        return overlayG;
    }
    
    /** Creates new form OverlayImagePanel */
    public OverlayImagePanelBean() {
        initComponents ();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the FormEditor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        
        setLayout(new java.awt.BorderLayout());
        
    }//GEN-END:initComponents

    /** Add a PropertyChangeListener to the listener list.
     * @param l The listener to add.
     */
    public void addPropertyChangeListener(java.beans.PropertyChangeListener l) {
        propertyChangeSupport.addPropertyChangeListener (l);
    }    

    /** Removes a PropertyChangeListener from the listener list.
     * @param l The listener to remove.
     */
    public void removePropertyChangeListener(java.beans.PropertyChangeListener l) {
        propertyChangeSupport.removePropertyChangeListener (l);
    }
    
    /** Getter for property overlay.
     * @return Value of property overlay.
     */
    public Image getOverlay() {
        return overlay;
    }
    
    /** Setter for property overlay.
     * @param overlay New value of property overlay.
     */
    public void setOverlay(Image overlay) {
        Image oldOverlay = this.overlay;
        this.overlay = overlay;
        propertyChangeSupport.firePropertyChange ("overlay", oldOverlay, overlay);
        
        repaint();
    }
    
    public boolean createOverlay() {
        if (srcImg != null) {
            int imageHeight = srcImg.getHeight(this);
            int imageWidth = srcImg.getWidth(this);
            if (imageHeight != -1 && imageWidth != -1) {
                overlay = super.createImage(imageWidth, imageHeight);
                if (overlay == null) {
                    System.out.println("Couldn't create overlay.");
                    return false;
                }
                
                overlayG = overlay.getGraphics();
                if (overlayG != null) {
                    // copy srcImg
                    overlayG.drawImage(srcImg, 0, 0, this);
                    
                    // add something
                    //overlayG.fillRect(0,0,100,100);
                } else {
                    //System.out.println("Couldn't get overlay graphics.");
                    overlay = null;
                    overlayG = null;
                    return false;
                }
                
                // set the preferred size of the panel
                this.setPreferredSize( new Dimension(imageWidth,imageHeight) );
            } else {
                overlay = null;
                overlayG = null;
                return false;
            }
        } else {
            overlay = null;
            overlayG = null;
            return false;
        }

        repaint();
        
        return true;
    }

    public void removeOverlay(){
        if ( overlayG != null ) {
            overlayG.dispose();
            overlayG = null;
        }
        overlay = null;
        repaint();
    }

    public boolean hasOverlay() {
        return (overlay != null);
    }
    
    public void storeOverlay() {
        // simply replace srcImg with current overlay
        //if (overlay != null) srcImg = overlay;
        
        if (overlay != null) {
            addJavaImage(overlay,0,0);
        }
    }
    
    /** Getter for property srcImg.
     * @return Value of property srcimg.
 */
    public Image getSrcImg() {
        return srcImg;
    }
    
    /** Setter for property srcImg.
     * @param srcImg New value of property srcImg.
 */
    public void setSrcImg(Image srcImg) {
        Image oldSrcImg = this.srcImg;
        this.srcImg = srcImg;
        propertyChangeSupport.firePropertyChange ("srcImg", oldSrcImg, srcImg);
        
        repaint();
    }
    
    public Dimension getSrcImgSize() {
        return new Dimension(srcImg.getWidth(this), srcImg.getHeight(this));
    }
    
    public void repaintNow() {
        // This code is not used by J/Link.
        // We need not call update() in this case :-)
        //update(this.getGraphics());//
        repaint();
    }
	
    public void update(Graphics g) {
        paint(g);
    }
	
    public void paint(Graphics g) {
        super.paint(g);
        //this.setForeground(Color.black);
        //this.setBackground(Color.white);
        
        //g.setColor(Color.white);
        //g.fillRect(0, 0, this.getBounds().width, this.getBounds().height);

        if (srcImg != null) {
            int imageHeight = srcImg.getHeight(this);
            int imageWidth = srcImg.getWidth(this);
            int totalWidth = getSize().width;
            int totalHeight = getSize().height;
            if (imageWidth != -1 && imageHeight != -1) {
                int left = (totalWidth - imageWidth)/2;
                int top = (totalHeight - imageHeight)/2;
                
                // because the overlay contains srcImg as a copy,
                // we need not draw it if the overlay exists.
                if (overlay != null) {
                    g.drawImage(overlay, left, top, this);
                } else {
                    g.drawImage(srcImg, left, top, this);
                }
                
                g.clearRect(0, 0, totalWidth, top);
                g.clearRect(0, top, left, imageHeight);
                g.clearRect(left + imageWidth, top, totalWidth - imageWidth - left, imageHeight);
                g.clearRect(0, top + imageHeight, totalWidth, totalHeight - imageHeight - top);
            } else {
                g.setColor(Color.white);
                g.fillRect(0, 0, this.getBounds().width, this.getBounds().height);
            }
        }
    }
	
    // image is drawn but it will be cleared when updating
    public void drawJavaImage(Image anImage, int x, int y) {
        if (anImage == null) {
            System.out.println("Couldn't drawJavaImage.");
            return;
        }
        
        int imageHeight = srcImg.getHeight(this);
        int imageWidth = srcImg.getWidth(this);
        int totalWidth = getSize().width;
        int totalHeight = getSize().height;
        if (imageWidth != -1 && imageHeight != -1) {
            int left = (totalWidth - imageWidth)/2;
            int top = (totalHeight - imageHeight)/2;
            // draw it on the panel
            getGraphics().drawImage(anImage, left+x, top+y, this);
        }
    }

    // image is drawn and it added to src
    public void addJavaImage(Image anImage, int x, int y) {
        if (anImage == null) {
            System.out.println("Couldn't addJavaImage.");
            return;
        }
        
        int imageHeight = srcImg.getHeight(this);
        int imageWidth = srcImg.getWidth(this);
        if (imageWidth != -1 && imageHeight != -1) {
            // create temporal offscreen
            Image offscreen = super.createImage(imageWidth, imageHeight);
            // get graphics of the offscreen
            Graphics g = offscreen.getGraphics();
            // add im on the offscreen
            g.drawImage(srcImg, 0, 0, this);
            // add anImage on the offscreen
            g.drawImage(anImage, x, y, this);
            // replace srcImg with new offscreen
            srcImg = offscreen;
            // refresh panel
            repaint();
        }
    }

    public Image createImage(int width, int height) {
        Image superImage = super.createImage(width, height);
        return superImage;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

}
